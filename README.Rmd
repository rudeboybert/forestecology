---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  fig.width = 16 / 2,
  fig.height = 9 / 2,
  message = FALSE,
  warning = FALSE,
  cache = FALSE
)
```

# forestecology 

[![Build Status](https://github.com/rudeboybert/forestecology/workflows/R-CMD-check/badge.svg)](https://github.com/rudeboybert/forestecology/actions)
[![Lifecycle: stable](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/forestecology)](https://cran.r-project.org/package=forestecology)


## Installation

You can install the released version of forestecology from [CRAN](https://CRAN.R-project.org) with:

```{r, eval = FALSE}
install.packages("forestecology")
```

And the development version from [GitHub](https://github.com/) with:

```{r, eval = FALSE}
# install.packages("remotes")
remotes::install_github("rudeboybert/forestecology")
```

This package is designed to work for spatially mapped, repeat censused forests plots. The package has commands to fit models of tree growth based on neighborhood competition which can be used to estimate species-specific competition coefficients. The models fits can then be evaluated using a spatial cross-validation scheme to detect possible overfitting. Additionally these models can test whether the species identity of competitors matters using a permutation test-style shuffling of competitor identity (under the null hypothesis) and subsequently evaluating if model performance changes. See Allen and Kim (2020) [A permutation test and spatial cross-validation approach to assess models of interspecific competition between trees](https://doi.org/10.1371/journal.pone.0229930) for a full description.  


## Example analysis

We present an example analysis using toy data pre-loaded into the package. 

```{r}
library(tidyverse)
library(forestecology)
library(sf)
library(sfheaders)
library(blockCV)
library(yardstick)
library(snakecase)
library(patchwork)
```

### Preprocess census data 

We first combine data from two repeat censuses into a single `tibble` and compute the growth of all surviving individuals. Note that per Allen and Kim (2020) we first remove resprouts from the second census.

```{r}
data(census_df1_ex, census_df2_ex)

# Filter out resprouts
census_df2_ex_no_r <- census_df2_ex %>%
  filter(!str_detect(codes, "R"))

# Merge both censuses and compute growth. Note we require any species variable
# to be coded as a factor
census_combined_ex <-
  compute_growth(census_df1_ex, census_df2_ex_no_r, id = "ID") %>%
  mutate(sp = to_any_case(sp) %>% as.factor())
```

### Add spatial information

Our growth model assumes that two individual trees compete if they are less than a pre-specified distance `max_dist` apart. Furthermore, we define a buffer region of size `max_dist` from the boundary of the study region. All trees outside this buffer region will be our "focal" trees of interest since we have complete competitor information on them. All trees inside this buffer region will only be considered as "competitor" trees to "focal" trees.

```{r}
data("ex_study_region")

# Set competitor distance
max_dist <- 1

# Create sf representation of buffer region
buffer_region <- ex_study_region %>% 
  compute_buffer_region(direction = "in", size = max_dist)

# Add buffer variable
census_combined_ex <- census_combined_ex %>%
  add_buffer_variable(direction = "in", size = max_dist, region = ex_study_region)

base_plot <- ggplot() +
  geom_sf(data = ex_study_region, fill = "transparent") +
  geom_sf(data = buffer_region, fill = "transparent", linetype = "dashed")

base_plot + 
  geom_sf(data = census_combined_ex, aes(col = buffer), size = 2)
```

We then manually define the blocks/folds for our spatial cross-validation scheme and convert them to an `sf` object using `sfheaders::sf_polygon()`:

```{r}
fold1 <- rbind(c(0, 0), c(5, 0), c(5, 5), c(0, 5), c(0, 0))
fold2 <- rbind(c(5, 0), c(10, 0), c(10, 5), c(5, 5), c(5, 0))

blocks <- bind_rows(
  sf_polygon(fold1),
  sf_polygon(fold2)
) %>%
  mutate(foldID = c(1, 2))
```

Next we assign each tree to blocks/folds using the `spatialBlock()` function from the [`blockCV`](https://github.com/rvalavi/blockCV) package.

```{r}
ex_cv_grid <- spatialBlock(
  speciesData = census_combined_ex, k = 2, selection = "systematic", blocks = blocks,
  showBlocks = FALSE, verbose = FALSE
)

# Add fold information to data
census_combined_ex <- census_combined_ex %>%
  mutate(foldID = ex_cv_grid$foldID %>% factor())

base_plot + 
  geom_sf(data = census_combined_ex, aes(col = buffer, shape = foldID), size = 2) +
  geom_sf(data = blocks, fill = "transparent", col = "orange")
```

We also extract the spatial cross-validation grid itself as an `sf` object for later use. 

```{r}
ex_cv_grid_sf <- ex_cv_grid$blocks %>%
  st_as_sf()

ggplot() +
  geom_sf(data = ex_cv_grid_sf)
```

### Define focal versus competitor trees

We then create a list-column data frame (via `tidyr::nest()`) where each row represents a focal tree of interest and the `comp` variable contains nested information on each of it's competitors


which has a row for each competing pair of individuals (each pair of individuals within `max_dist` of one another):

```{r}
focal_vs_comp_ex <- census_combined_ex %>%
  create_focal_vs_comp(max_dist, cv_grid_sf = ex_cv_grid_sf, id = "ID")

# Nested view
focal_vs_comp_ex

# Unnested view:
focal_vs_comp_ex %>% 
  unnest(cols = "comp")
```

### Fit model and make predictions

We then fit our competitor growth model as specified in Allen and Kim (2020)

```{r}
comp_bayes_lm_ex <- focal_vs_comp_ex %>%
  comp_bayes_lm(prior_param = NULL, run_shuffle = FALSE)
```

Since the resulting output is an S3 object of class `comp_bayes_lm`, we can both print and visualize its output: the posterior distribution of all the linear regression parameters. 

```{r}
# Object summary
comp_bayes_lm_ex

# Visualizations (combined with patchwork pkg)
p1 <- autoplot(comp_bayes_lm_ex, type = "intercepts")
p2 <- autoplot(comp_bayes_lm_ex, type = "dbh_slopes")
p3 <- autoplot(comp_bayes_lm_ex, type = "competition")
(p1 | p2) / p3
```

Furthermore, we append fitted/predicted growth values for each tree using `predict.comp_bayes_lm()` to our data frame and then compute the root mean squared error (RMSE).

```{r}
focal_vs_comp_ex <- focal_vs_comp_ex %>%
  mutate(growth_hat = predict(comp_bayes_lm_ex, focal_vs_comp_ex))

# Compute RMSE
focal_vs_comp_ex %>%
  yardstick::rmse(truth = growth, estimate = growth_hat) %>%
  pull(.estimate)
```

### Run spatial cross-validation

Here we repeat the process but with running spatial cross-validation: we fit the data to one fold and apply it to the other. Note the increase in RMSE, reflecting the fact that our original estimate of model error was overly optimistic as it did not account for spatial autocorrelation.

```{r}
ex_bw <- focal_vs_comp_ex %>%
  run_cv(max_dist = max_dist, cv_grid = ex_cv_grid_sf) %>%
  right_join(census_combined_ex, by = c("focal_ID" = "ID"))

# Compute RMSE of spatially cross-validated model
ex_bw %>%
  rmse(truth = growth, estimate = growth_hat) %>%
  pull(.estimate)
```

<!--For fuller examples on actual datasets see ___.-->
