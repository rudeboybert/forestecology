---
title: "`forestecology` package for modeling interspecies competition between trees"
blinded: 0
authors: 
- name: Albert Y. Kim 
  thanks: "Albert Y. Kim is Assistant Professor, Statistical & Data Sciences, Smith College, Northampton, MA 01063 (e-mail: akim04@smith.edu)."
  affiliation: Program in Statistical & Data Sciences, Smith College
- name: David Allen
  affiliation: Biology Department, Middlebury College
keywords:
- forest ecology.
abstract: 
- "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
  tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis
  nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis
  aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat
  nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
  officia deserunt mollit anim id est laborum."
bibliography: paper.bib
output: rticles::asa_article
link-citations: yes
header-includes:
- \usepackage{xcolor, soul, xspace, float, subfig}
---


```{r setup, include = FALSE, cache = FALSE}
# knitr settings
knitr::opts_chunk$set(
  # Code output:
  warning = FALSE,
  message = FALSE,
  echo = TRUE,
  cache = TRUE,
  # Figure:
  out.width = "100%",
  fig.path = "Figures/",
  fig.width = 16 / 2.5,
  fig.height = 9 / 2.5,
  fig.align = "center",
  fig.show = "hold",
  # Etc:
  collapse = TRUE,
  comment = "##"
  # tidy = FALSE
)

# Internally used packages
library(knitr)
library(ggplot2)
library(viridis)

# Random number generator seed value
set.seed(76)

# Set ggplot defaults output:
if (!knitr::is_html_output()) {
  # Grey theme:
  theme_set(theme_light())
  # Color scheme
  scale_colour_discrete <- scale_colour_viridis_d
}

# Set output width
options(width = 70)
```





# Introduction

Repeat-censused forest plots offer excellent data to test neighborhood models of tree competition @allen_permutation_2020 @canham_neighborhood_2006 @uriarte_spatially_2004. Here we describe an R package, `forestecology`, to do that. This package implements the methods in @allen_permutation_2020. It provides: a convenient way specify and fit models of tree growth based on neighborhood competition; a spatial cross validation method to test and compare model fits @roberts_cross-validation_2017; and an ANOVA-like method to assess whether the competitor identity matters in these models. The model is written to work with ForestGEO plot data @andersonteixeira_ctfs-forestgeo_2015, but we envision that it could easily be modified to work with data from other forest plots, e.g. the US Forest Service Forest Inventory and Analysis plots @smith_forest_2002.


# Example

We demonstrate the `forestecology` package's features on two data sets, both based on inventory censuses of two sites from the Smithsonian Institution’s ForestGEO international network of 72 long‐term forest dynamics research sites @andersonteixeira_ctfs-forestgeo_2015. First, the Michigan Big Woods Forest Dynamics Plot located at the Edwin S. George Reserve in Pinckney, MI, USA. The 23 ha plot is situated in mature oak-hickory forest. The canopy is dominated by white oak (Quercus alba), northern red oak (Quercus rubra), black oak (Quercus velutina), shagbark hickory (Carya ovata) and pignut hickory (Carya glabra). The most common understory tree is witch-hazel (Hamamelis virginiana) @allen_michigan_2020. In the example below, we will preface any data frames from this plot in with `bw_`.

Second, the Smithsonian Conservation Biology Institute (SCBI) large forest dynamics plot, located at the Smithsonian's National Zoo and Conservation Biology Institute in Front Royal, VA, USA. The 25.6 ha (640 x 400 m) plot is located at the intersection of three of the major physiographic provinces of the eastern US: the Blue Ridge, Ridge and Valley, and Piedmont provinces and is adjacent to the northern end of Shenandoah National Park. The forest type is typical mature secondary eastern mixed deciduous forest, with a canopy dominated by tulip poplar (Liriodendron tulipifera), oaks (Quercus spp.), and hickories (Carya spp.), and an understory composed mainly of spicebush (Lindera benzoin), paw-paw (Asimina triloba), American hornbeam (Carpinus caroliniana), and witch hazel (Hamamelis virginiana) @bourg_initial_2013. In the example below, we will preface any data frames from this plot in with `scbi_`.





## Load packages & preprocess census data 

```{r load-packages}
library(forestecology)

# Load tidyverse packages:
library(tidyverse)
library(lubridate)

# Load spatial packages:
# devtools::install_github("rvalavi/blockCV")
library(blockCV)
library(sf)
library(sfheaders)

# Load other packages:
library(snakecase)
library(yardstick)
```


We start by preprocessing the census data for both sites. While ForestGEO data protocols ensure a high degree of standardization between site, minor variations still exist @andersonteixeira_ctfs-forestgeo_2015. While the Big Woods data comes pre-loaded in the `forestecology` package, we load the SCBI data as they are saved in .csv files in the SCBI-ForestGEO-Data repository on GitHub @gonzalez-akre_scbi-forestgeoscbi-forestgeo-data_2020.  In both cases, we load the census data as R as "tibble" data frames thereby ensuring a standardized input/output format that can be used across all `tidyverse` packages @wickham_welcome_2019. 

Furthermore, we ensure that the different variables have the correct names, types (`dbl`, `data`, `factor`). 

### Big Woods

We load census data from 2008 and 2014 saved in the package, then merge species data (genus, species, linnean classification, family, etc). 

```{r bw-load-data}
data(bw_census_2008, bw_census_2014, bw_species)

# Append additional species data
bw_census_2008 <- bw_census_2008 %>%
  left_join(bw_species, by = "sp") %>%
  select(-c(genus, species, latin))
```

### SCBI {#scbi-data}

We load census data from 2008 and 2014 from `.csv` files saved from GitHub on November 20, 2020. Furthermore, we perform two additional pre-processing steps. First, in order to speed up computation for purposes of this example, we only consider a 9 ha subsection of the 25.6 ha of the SCBI site: `gx` from 0--300 instead of 0--400 and `gy` from  300--600 instead of 0--640. Second, in order to standardize comparisons between Big Woods and SCBI, we convert the units of dbh from mm to cm. ^[A rule of thumb to ascertain if dbh is in mm or cm is to verify if the smallest non-zero and non-missing measurement is 1 or 10. If the former, then cm. If the later, then mm. This is because ForestGEO protocols state that only trees with dbh greater or equal to 1cm should be included in censuses. ]

```{r scbi-load-data}
scbi_2013 <- read_csv("scbi.stem2.csv") %>%
  select(treeID, stemID, sp, ExactDate, gx, gy, dbh, codes, status) %>%
  mutate(
    date = ExactDate,
    dbh = as.numeric(dbh),
    date = mdy(date)
  ) %>%
  filter(gx < 300, between(gy, 300, 600)) %>% 
  mutate(dbh = dbh / 10)

scbi_2018 <- read_csv("scbi.stem3.csv") %>%
  select(treeID, stemID, sp, ExactDate, gx, gy, dbh, codes, status) %>%
  mutate(
    date = ExactDate,
    dbh = as.numeric(dbh),
    date = mdy(date)
  ) %>%
  filter(gx < 300, between(gy, 300, 600)) %>% 
  mutate(dbh = dbh / 10)
```



## Compute growth

For each plot we then compute average annual growth between the two censuses using the `compute_growth()` function. This function takes the two census data frames as well as a character indicating which variable in both data frames uniquely identifies each stem. This function returns a single data frame that includes a numerical variable `growth` reflecting the average annual dbh growth (in cm) of all trees alive at both time points. Furthermore, variables that (in theory) remain unchanged between censuses appear only once, such as location variables `gx` and `gy`; as well as species-related variables. Variables that should change between censuses are suffixed with `1` and `2` indicating the earlier and later censuses, such as `dbh1/dbh2` and `codes1/codes2`. Here the resulting data frames are named with some variation of `growth_df`.

After computing the average annual growth for each tree, we ensure to convert all variables denote species from type character to factors; this is to ensure that issues of rare species being accounted for in both training and test sets in our upcoming cross-validation step (see Section REF)

### Big Woods

In the case of Big Woods data, we first remove all trees that were re-sprouts in the later (2014) census. Additionally, we have included three classification of tree species: `species`, `family`, and `trait_group`. DESCRIBE THESE

```{r bw-compute-growth}
bw_census_2014 <- bw_census_2014 %>%
  filter(!str_detect(codes, "R"))

bw_growth_df <-
  compute_growth(bw_census_2008, bw_census_2014, id = "treeID") %>%
  # Convert all variables denoting species to factors
  mutate(
    sp = sp %>% to_any_case() %>% as.factor(),
    species = sp,
    family = as.factor(family),
    trait_group = as.factor(trait_group)
  ) %>%
  # Drop unnecessary variables
  select(-stemID)
```

### SCBI

```{r scbi-compute-growth}
scbi_growth_df <-
  compute_growth(scbi_2013, scbi_2018, "stemID") %>%
  # Convert all variables denoting species to factors
  mutate(sp = as.factor(sp))
```

### Comparison

Figure \ref{fig:growth-histogram} displays histograms comparing the distribution of average annual growth at both sites. Observe that average annual growth appears higher at the Big Woods site. 

```{r growth-histogram, out.width="100%", fig.cap="Distribution of average annual growth in DBH for both sites."}
# Both Big Woods & SCBI
bind_rows(
  bw_growth_df %>% st_drop_geometry() %>% select(growth) %>% mutate(Site = "Big Woods"),
  scbi_growth_df %>% st_drop_geometry() %>% select(growth) %>% mutate(Site = "SCBI")
) %>% 
  ggplot(aes(x = growth, y = ..density.., fill = Site)) +
  geom_histogram(alpha = 0.5, position = "identity", binwidth = 0.05) +
  labs(x = "Average annual growth in dbh (cm per yr)") +
  coord_cartesian(xlim = c(-0.5, 1))
```



## Add spatial information

We now encode spatial information to the `growth_df` data frames. First, in order to control for study region edge effects, we add "buffers" to the periphery of the study region (cite Waller?). Our model of interspecific competition relies on a spatial definition of who the competitor trees are for focal trees of interest. Since certain explanatory variables such as biomass are cumulative, we must ensure that all trees being modeled are not biased to have different neighbor structures. This is a particular concern for trees at the boundary of study regions, which will not have the same number of neighbors as trees in the internal part of the study region. 

Second, our ultimate method for model assessment will rely on estimates of model error as generated by cross-validation. Conventional cross-validation schemes assign observations to folds by resampling individual observations at random. However, underlying this scheme is an assumption that the observations are independent. In the case of forest census data, observations exhibit spatial autocorrelation, and thus this dependence must be incorporated in our resampling scheme in spatial cross-validation @roberts2017 @pohjankukka2017. We will therefore associate portions of the study region to spatial folds. 

To these two ends, we define two constants, both of which are in the same units as the `gx` and `gy` variables (most often meters). 

```{r}
max_dist <- 7.5
cv_fold_size <- 100
```

The first constant is `max_dist` which defines the maximum distance for a tree's competitive neighborhood. Trees within this distance of each other are assumed to compete while those farther than this distance apart do not. Put differently, all trees within `max_dist` of a focal tree will be considered its competitors (see below). Other studies have estimated the value of `max_dist`; we use an average of estimated values @canham_neighborhood_2004, @uriarte_spatially_2004, @tatsumi2013, @canham_neighborhood_2006. 

Furthermore, `max_dist` will define the size of all buffers considered, which will be encoded as a binary variable `buffer` as computed by the `add_buffer_variable()` function. This function takes as input the main `growth_df` data frame, the `size` of the buffer which we set as `max_dist`, and the boundary of the study region encoded as a simple features polygon @pebesma_simple_2018. DESCRIBE SF PACKAGE. In the Big Woods example below we will use a pre-loaded simple features polygon while for the SCBI example we present example code on how to manually construct one. 

The second constant is `cv_fold_size` which defines the length and width of the spatial folds (note that for now the spatial folds are restricted be squares). We will then use this constant to associate each observed tree to one of $k$ folds in the respective study region. In the Big Woods example below we will use the `blockCV` R package that has implemented spatial cross-validation while for the SCBI we will do this manually @valavi2019.


### Big Woods

First, we indicate which trees are part of the buffer. This necessitates information about the study region boundary. In this case, we use a `sf_polygon` object `bw_study_region` which comes pre-loaded in the `forestecology` packages. After loading `bw_study_region`, we illustrate the results of the `add_buffer_variable()` function in Figure \ref{fig:bw-define-buffer}. Trees on the periphery denote with lighter colors are part of the buffer and will not be considered as "focal" trees of interest going forward; they will only be considered as competitor trees. 

```{r bw-define-buffer, out.width="100%", fig.cap="Buffer region for Big Woods study region."}
data(bw_study_region)

bw_growth_df <- bw_growth_df %>%
  add_buffer_variable(direction = "in", size = max_dist, region = bw_study_region)

ggplot() +
  geom_sf(data = bw_growth_df, aes(col = buffer), size = 0.5)
```

Second, we associate each tree to spatial cross validation folds. In this case, we use the `spatialBlock()` function from the `blockCV` package to define the spatial grid which 

THIS IS A MESS. We use the  @valavi_blockcv_2019, whose elements will act as the folds in our leave-one-out (by "one" we mean "one grid block") cross-validation scheme. The upshot here is we add `foldID` to `growth_df` which identifies which fold each individual is in, and the creation of a `cv_grid_sf` object which gives the geometry of the cross validation grid.

```{r bw-define-cv-folds}
set.seed(76)
bw_cv_grid <- spatialBlock(
  speciesData = bw_growth_df, theRange = cv_fold_size, verbose = FALSE,
  k = 28, xOffset = 0.5, yOffset = 0
)

bw_cv_grid_sf <- bw_cv_grid$blocks %>%
  st_as_sf()

# Add foldID to each tree
bw_growth_df <- bw_growth_df %>%
  mutate(foldID = bw_cv_grid$foldID)

# Visualize grid. Why does fold 19 repeat?
bw_cv_grid$plots +
  geom_sf(data = bw_growth_df %>% sample_frac(0.2), aes(col = factor(foldID)), size = 0.1)

bw_growth_df <- bw_growth_df %>%
  filter(!foldID %in% c(19, 23, 21, 17, 8, 19)) %>%
  mutate(foldID = as.character(foldID))
```

### SCBI

First, we indicate which trees are part of the buffer. In this case however we manually define the study region boundary based on the subregion we defined in Section \ref{scbi-data} and create an `sf_polygon` object using the `sf_polygon()` function from the `sfheaders` package. Figure \ref{fig:scbi-define-buffer} displays the resulting buffer trees. 

```{r scbi-define-buffer, out.width="100%", fig.cap="Buffer region for SCBI study region."}
scbi_study_region <- tibble(
  x = c(0, 300, 300, 0, 0),
  y = c(300, 300, 600, 600, 300)
) %>%
  sf_polygon()

scbi_growth_df <- scbi_growth_df %>%
  add_buffer_variable(direction = "in", size = max_dist, region = scbi_study_region)

ggplot() +
  geom_sf(data = scbi_growth_df, aes(col = buffer), size = 0.5)
```

Second, we associate each tree to spatial cross validation folds. In this case we define a 
HEY BERT PICK IT UP HERE
CONVERT THIS TO MANUAL DEFINITON OF GRID based on old/spatial_block_issue.R

```{r scbi-define-cv-folds}
fold1 <- rbind(c(0, 300), c(150, 300), c(150, 600), c(0, 600), c(0, 300))
fold2 <- rbind(c(150, 300), c(300, 300), c(300, 600), c(150, 600), c(150, 300))
blocks <- bind_rows(
  sf_polygon(fold1),
  sf_polygon(fold2) ) %>%
  mutate(foldID = c(1, 2))

ggplot() +
  geom_sf(data = scbi_growth_df, aes(col = buffer), size = 2) +
  geom_sf(data = blocks, fill = "transparent")






scbi_cv_grid <- spatialBlock(
  speciesData = scbi_growth_df, theRange = cv_fold_size, yOffset = 0.9999, 
  k = 9, verbose = FALSE
)


scbi_cv_grid_sf <- scbi_cv_grid$blocks %>%
  st_as_sf()

# Add foldID to each tree
scbi_growth_df <- scbi_growth_df %>%
  mutate(foldID = scbi_cv_grid$foldID)

# Visualize grid
scbi_cv_grid$plots +
  geom_sf(data = scbi_growth_df, aes(col = factor(foldID)), size = 0.1)


ggplot() +
  geom_sf(data = scbi_cv_grid_sf)
```



## Focal versus competitor trees

Next we create the `focal_vs_comp` data frame which connects each tree in `growth_df` to the trees in its competitive neighborhood range (as defined by `max_dist`). So for example, if `growth_df` consisted of two focal trees with two and three neighbors respectively, `focal_vs_comp` would consist of 5 rows. This requires the `growth_df` data frame; `max_dist`, the scalar defining competitive range; `cv_grid_sf`, giving the cross validation grid; and the `id` variable as inputs.

### Big Woods

```{r bw-focal-vs-comp, eval = FALSE}
focal_vs_comp_bw <- bw_growth_df %>%
  create_focal_vs_comp(max_dist, cv_grid_sf = bw_cv_grid_sf, id = "treeID")

glimpse(focal_vs_comp_bw)
```

### SCBI 

```{r scbi-focal-vs-comp, eval = FALSE}
focal_vs_comp_scbi <- scbi_growth_df %>%
  create_focal_vs_comp(max_dist, cv_grid_sf = scbi_cv_grid_sf, id = "stemID")

glimpse(focal_vs_comp_scbi)
```



## Model fit and prediction

We fit a linear regression model. However, to speed computation we assume a linear. 

### Big Woods 

Now we are ready to fit the competition model with `fit_bayesian_model`. This function needs only the `focal_vs_comp` as an input. Other options allow the user to specify prior parameters and run a competitor-species identity shuffle (see below).

```{r bw-model-fit, eval = FALSE}
# Big Woods
posterior_param_bw <- focal_vs_comp_bw %>%
  fit_bayesian_model(prior_param = NULL, run_shuffle = FALSE)
```

This output has the posterior parameters for the specified competition model. This `posterior_param` output can be used to get predicted growths for each individual (with `predict_bayesain_model`) to test how well the model performs. Or this `posterior_param` output can be plotted (either the betas or lambdas with `plot_posterior_params`) to understand what controls growth and the nature of the competitive ineractions.

Here we calculate the RMSE

```{r bw-model-RMSE, eval = FALSE}
predictions <- focal_vs_comp_bw %>%
  predict_bayesian_model(posterior_param = posterior_param_bw) %>%
  right_join(bw_growth_df, by = c("focal_ID" = "treeID"))
predictions %>%
  rmse(truth = growth, estimate = growth_hat) %>%
  pull(.estimate)
```

Now we test whether the identity of the competitor matters. We do this by shuffling the identity of competitors (but not of focal trees or spatial locations or sizes) and fitting the model again. We then compare RMSEs to see whether competitor identity matters to competitive interactions.

```{r bw-model-shuffle, eval = FALSE}
posterior_param_bw_shuffle <- focal_vs_comp_bw %>%
  fit_bayesian_model(prior_param = NULL, run_shuffle = TRUE)

# b) Make predictions and compute RMSE
predictions_shuffle <- focal_vs_comp_bw %>%
  predict_bayesian_model(posterior_param = posterior_param_bw_shuffle) %>%
  right_join(bw_growth_df, by = c("focal_ID" = "treeID"))
predictions_shuffle %>%
  rmse(truth = growth, estimate = growth_hat) %>%
  pull(.estimate)
```

The RMSE is lower for the non-shuffled version. This gives support for the idea that competitor identity does matter for competitive interactions. 

### SCBI 

```{r scbi-model-fit, eval = FALSE}
posterior_param_scbi <- focal_vs_comp_scbi %>%
  fit_bayesian_model(prior_param = NULL, run_shuffle = FALSE)
```

Here we provide examples of seeing how well the model fits and then a spatial plot of the residuals to see whether there are any consistent spatial patterns to them.

```{r scbi-model-residuals, eval = FALSE}
# SCBI
scbi_growth_df_noCV <- focal_vs_comp_scbi %>%
  predict_bayesian_model(posterior_param = posterior_param_scbi) %>%
  right_join(scbi_growth_df, by = c("focal_ID" = "stemID"))

scbi_growth_df_noCV %>%
  rmse(truth = growth, estimate = growth_hat) %>%
  pull(.estimate)

# Observed vs predicted growth
ggplot(scbi_growth_df_noCV, aes(x = growth, y = growth_hat)) +
  geom_point(size = 0.5, color = rgb(0, 0, 0, 0.25)) +
  stat_smooth(method = "lm") +
  geom_abline(slope = 1, intercept = 0) +
  coord_fixed() +
  labs(
    x = "Observed growth in dbh", y = "Predicted growth in dbh",
    title = "Predicted vs Observed Growth"
  )

reslab <- expression(paste("Residual (cm ", y^{
  -1
}, ")"))
scbi_growth_df_noCV %>%
  st_as_sf() %>%
  # Need to investigate missingness
  filter(!is.na(growth_hat)) %>%
  mutate(
    error = growth - growth_hat,
    error_bin = cut_number(error, n = 5),
    error_compress = ifelse(error < -0.75, -0.75, ifelse(error > 0.75, 0.75, error))
  ) %>%
  ggplot() +
  geom_sf(aes(col = error_compress), size = 1) +
  theme_bw() +
  scale_color_gradient2(
    low = "#ef8a62", mid = "#f7f7f7", high = "#67a9cf",
    name = reslab,
    breaks = seq(from = -0.75, to = 0.75, by = 0.25),
    labels = c("< -0.75", "-0.5", "0.25", "0", "0.25", "0.5", "> 0.75")
  ) +
  labs(x = "Meter", y = "Meter")
```



## Run spatial cross-validation

For the above results we fit the model to the entire data set, and then make predictions across the entire data set from that fit. This could lead to overfitting because we are using the training data to also test the model. If model error is spatially correlated this could be a large issue (cite important sources here!). We can use the spatial block structure we defined above to deal with with. The function `run_cv` goes through each fold in the `cv_grid_sf` and fits the model on all the other folds. Then applies that fit to the focal fold. It is a wrapper for `fit_bayesain_model` and `predict_bayesain_model` but fits a separate model for each fold.

### Big Woods

```{r bw-spatial-cv, eval = FALSE}
cv_bw <- focal_vs_comp_bw %>%
  run_cv(max_dist = max_dist, cv_grid = bw_cv_grid) %>%
  right_join(bw_growth_df, by = c("focal_ID" = "treeID"))

cv_bw %>%
  rmse(truth = growth, estimate = growth_hat) %>%
  pull(.estimate)
```

As expected this RMSE is higher than that when the model is fit without cross validation. See Allen and Kim (2020) for more discussion of this. 

### SCBI

```{r scbi-spatial-cv, eval = FALSE}
cv_scbi <- focal_vs_comp_scbi %>%
  run_cv(max_dist = max_dist, cv_grid = scbi_cv_grid) %>%
  right_join(scbi_growth_df, by = c("focal_ID" = "treeID"))

cv_scbi %>%
  rmse(truth = growth, estimate = growth_hat) %>%
  pull(.estimate)
```

Here also this RMSE is much higher than that for the above SCBI model fit without cross validation. 



## Visualize posterior distributions

Lastly, we present tools to explore the posterior distributions of all parameters in our model. 

### Big Woods 

We might be interested in the posterior distributions of parameters. The betas tell us about how fast each species grows and how this depends on DBH. The lambdas, often of more interest, are the species-specific competition coefficients. The full lambda matrix gives competition strength between species. There is a rich literature on this matrix (cite). 

Because of the structure of the `bw_fit_model` object we cannot simply draw these curves based on the posterior distribution. `bw_fit_model` gives the parameters *compared* to a baseline. This is not of direct interest. So to display these parameters, as we care about them, we have to sample from the baseline distribution and from the comparison one to get the posterior distribution of interest. 

Here we re-run the Big Woods model but using the family as the group for comparison. This makes the posterior distributions easier to follow. Also, surprisingly, grouping by family performed just as well as grouping by species (see Allen and Kim 2020). First we re-run `create_focal_vs_comp` and `fit_bayesian_model` with the grouping variable as family.

```{r bw-posterior-viz-0, eval = FALSE}
focal_vs_comp_bw <- bw_growth_df %>%
  # mutate(sp = trait_group) %>%
  mutate(sp = family) %>%
  create_focal_vs_comp(max_dist = max_dist, cv_grid_sf = bw_cv_grid_sf, id = "treeID")

# a) Fit model (compute posterior parameters) with no permutation shuffling
posterior_param_bw <- focal_vs_comp_bw %>%
  fit_bayesian_model(prior_param = NULL, run_shuffle = FALSE)
```

Now the output of `fit_bayesian_model` is passed to `plot_posterior_parameters`.

```{r bw-posterior-viz-1, eval = FALSE}
# b) Recreate Fig5 from Allen (2020): Posterior distributions of selected lambdas
posterior_plots <- plot_posterior_parameters(
  posterior_param = posterior_param_bw,
  sp_to_plot = c("cornaceae", "fagaceae", "hamamelidaceae", "juglandaceae", "lauraceae", "rosaceae", "sapindaceae", "ulmaceae")
)
```

The output is a list with three plots stored. The element `beta_0` gives the growth intercept, i.e., how fast an individual of each group grows independent of DBH).

```{r bw-posterior-viz-beta0, eval = FALSE}
posterior_plots[["beta_0"]]
```

Next `beta_dbh` gives the DBH-growth slope for each group.

```{r bw-posterior-viz-beta-dbh, eval = FALSE}
posterior_plots[["beta_dbh"]]
```

Finally `lambda` gives the competition coeffiencts.

```{r bw-posterior-viz-lambda, eval = FALSE}
posterior_plots[["lambda"]]
```


### SCBI

```{r scbi-posterior-viz-1, eval = FALSE}
posterior_plots_scbi <- plot_posterior_parameters(
  posterior_param = posterior_param_scbi,
  sp_to_plot = c("quru", "litu", "cagl", "cato")
)
```

```{r scbi-posterior-viz-lambda, eval = FALSE}
posterior_plots_scbi[["lambda"]]
```





# Conclusions





# Acknowledgements





# References




